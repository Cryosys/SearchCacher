@page "/"
@using SearchCacher.Data
@using System.ComponentModel.DataAnnotations
@using Syncfusion.Blazor.Buttons;
@using Syncfusion.Blazor.Grids
@using Syncfusion.Blazor.Navigations;
@using Syncfusion.Blazor.Inputs;
@using Syncfusion.Blazor.Notifications
@inject SearchService searchService
@inject IJSRuntime JSRuntime

<PageTitle>OnlySearch</PageTitle>

<SfToast ID="toast_default" @ref="data.ToastObj" Title="Info" Timeout="5000" Icon="e-meeting">
    <ToastPosition X="Right" Y="Top" />
</SfToast>

<div>
    <div style="display:flex;align-items:start">
        <SfAccordion Width="auto" LoadOnDemand="false" style="min-width:300px">
            <AccordionItems>
                <AccordionItem Header="Settings" Expanded="true">
                    <ContentTemplate>
                        <table style="margin:10px;white-space:nowrap">
                            <thead>
                                <tr>
                                    <th style="padding-right:30px">Status</th>
                                    <th>Setting</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td><SfSwitch @bind-Checked="data.searchOnlyFileExt" /></td><td>Only search in extensions</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.searchOnFullPath" /></td><td>Search on full path</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.searchDirs" /></td><td>Directories</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.searchFiles" /></td><td>Files</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.caseSensitive" /></td><td>Case sensitive search</td></tr>
                            </tbody>
                        </table>
                    </ContentTemplate>
                </AccordionItem>
            </AccordionItems>
        </SfAccordion>
        <SfAccordion LoadOnDemand="false">
            <AccordionItems>
                <AccordionItem Header="Info" Expanded="true">
                    <ContentTemplate>
                        Enabling only extensions makes the search absolut. Meaning that only the specified extension will be searched for. <br />
                        Example: You want to search for all txt files. Input only .txt in the search box, all other settings do not matter.<br />
                        @* <s>
                        The pattern is relative, meaning that '.txt' will only find a file for example that does not have a name and ends with '.txt'. Entering '*.txt' however will search for all files ending with '.txt'. <br />
                        Entering 'nua*' will search for all files and folders containing the char set 'nua' at any point in the name. Like Manual -> Ma*nua*l.
                        </s> *@
                        <br />
                        <br />
                        The search pattern is Regex based. <a href="https://regex101.com/" target="_blank">You can test and generate regex patterns here.</a><br />
                        Tl:dr; writing only a word, for example 'test' will find all paths involing this word, regardless of upper or lower case and anywhere in the path. <br />
                        It does not matter if the word has something before or after it. Writing 'subfolder*.*test' will find all paths that have at some point subfolder in it and AFTER it somewhere test. <br />
                        The search will only search in paths if you enable the option, this will take a bit more time, but not that much more.
                        <br />
                        Search paths * is equal to the base path of the search: @searchService.SearchPath
                    </ContentTemplate>
                </AccordionItem>
            </AccordionItems>
        </SfAccordion>
    </div>
    <br />

    <div style="display:flex;flex-direction:row;text-align:center;align-items:center">
    </div>

    <div style="display:flex;flex-direction:row;text-align:center;align-items:center">
        <span style="margin-right:5px;width:auto;white-space:nowrap">Search path:</span>
        <SfTextBox Multiline="false" @bind-Value="data.searchPath" style="min-width:400px" @onkeyup="@PatternTextBoxKeyUp" />
        <span style="margin-left:5px;margin-right:5px">Pattern:</span>
        <SfTextBox Multiline="false" Placeholder="*nua*" @bind-Value="data.pattern" style="min-width:400px" @onkeyup="@PatternTextBoxKeyUp" />
        <SfButton style="margin:5px" @onclick=Search>Search</SfButton>
        <div style="position:relative;width:50px;margin:5px">
            <SfSpinner Size="20" @bind-Visible="@data.IsSpinnerVisible" />
        </div>
    </div>

    <SfGrid @ref="FileGrid" TValue="string" DataSource="@data.Paths" AllowSorting="true" ContextMenuItems="@FileGridContextMenuItems" EnableVirtualization="true" Height="800">
        <GridSelectionSettings Mode="SelectionMode.Row" EnableSimpleMultiRowSelection="false"></GridSelectionSettings>
        <GridEvents ContextMenuItemClicked="OnContextMenuClick" TValue="string"></GridEvents>
        <GridColumns>
            <GridColumn HeaderText="File" IsPrimaryKey="true">
                <Template>
                    @{
                        <div>@(context as string)</div>
                    }
                </Template>
            </GridColumn>
        </GridColumns>
    </SfGrid>

    <br />
    Last search time @data.lastSearchTime min:sec:ms
</div>

<script>
    async function copyClipboard(text) {
        console.log(text);

        try {
            await navigator.clipboard.writeText(text);
        } catch (error) {
            console.error(error.message);
        }
    }
</script>

@code {
    class FormData
    {
        public SfToast ToastObj;

        public bool IsSpinnerVisible { get; set; } = false;

        public string?[]? Paths { get; set; } = null;

        public string pattern { get; set; } = "nua*";

        public Task<ISearcher.SearchResult>? searchTask;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchOnlyFileExt { get; set; } = false;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchOnFullPath { get; set; } = false;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchDirs { get; set; } = true;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchFiles { get; set; } = true;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool caseSensitive { get; set; } = false;

        [Required]
        public string searchPath { get; set; } = "*";

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool SpinnerVisible { get; set; } = false;

        public string? lastSearchTime { get; set; } = null;
    }

    FormData data = new FormData();

    private SfGrid<string> FileGrid;

    List<object> FileGridContextMenuItems = new()
    {
        new ContextMenuItemModel() { Text = "Copy filename", Target = ".e-content", Id = "copyfilename" },
        new ContextMenuItemModel() { Text = "Copy folderpath", Target = ".e-content", Id = "copyfolderpath" },
        new ContextMenuItemModel() { Text = "Copy path", Target = ".e-content", Id = "copypath" },
        new ContextMenuItemModel() { Text = "Search in path", Target = ".e-content", Id = "searchinpath" },
    };

    protected async Task Search()
    {
        if (data.searchTask is not null)
        {
            ShowToast("Previous search is still in progress...", 10000);
            return;
        }

        if (string.IsNullOrWhiteSpace(data.pattern))
        {
            ShowToast("Empty search pattern is not allowed.", 10000);
            return;
        }

        try
        {
            if (!data.searchOnlyFileExt)
                System.Text.RegularExpressions.Regex.IsMatch("", data.pattern);
        }
        catch (ArgumentException)
        {
            ShowToast("Pattern is not a valid regex pattern", 10000);
            return;
        }

        ShowToast("Starting search...");
        data.IsSpinnerVisible = true;
        await Task.Delay(100);
        data.Paths = null;

        DateTime preSearch = DateTime.Now;
        data.searchTask = searchService.GetSearchResult(new SearchSettings(data.pattern, data.searchOnlyFileExt, data.searchDirs, data.searchFiles, data.searchOnFullPath, data.caseSensitive, data.searchPath));
        await data.searchTask;
        if (data.searchTask.Status != TaskStatus.RanToCompletion)
        {
            await Task.Delay(100);
            ShowToast("Failed to complete search. Ex: " + data.searchTask.Exception?.ToString(), 10000);
            return;
        }

        ISearcher.SearchResult result = data.searchTask.Result;

        data.lastSearchTime = (DateTime.Now - preSearch).ToString(@"mm\:ss\:ffff", new System.Globalization.CultureInfo("en-US"));
        data.IsSpinnerVisible = false;
        data.Paths = result.Result;
        data.searchTask = null;

        await Task.Delay(100);
        if (!result.Success)
            ShowToast(result.Error, 10000);
        else
            ShowToast("Finished search");
    }

    protected async void ShowToast(string info, int timeout = 5000)
    {
        await this.data.ToastObj.ShowAsync(new ToastModel()
            {
                Content = info,
                Timeout = timeout
            });
    }

    public void OnContextMenuClick(ContextMenuClickEventArgs<string> args)
    {
        var selectionTask = FileGrid.GetSelectedRecordsAsync();
        if (!selectionTask.Wait(5000))
        {
            ShowToast("Failed to copy to clipboard");
            return;
        }

        var entries = selectionTask.Result;
        if (entries.Count == 0)
        {
            ShowToast("Somehow no path was selected in the grid, please try again...");
            return;
        }

        List<string> copyText = new List<string>();

        if (args.Item.Id == "searchinpath")
        {
            if (entries.Count > 1)
            {
                // We do not know which path is the desired search path
                ShowToast("More than 1 path is selected, please only select one in order to use it as the search path");
                return;
            }

            data.searchPath = Path.GetDirectoryName(entries.First()) ?? "";
        }
        else
            foreach (var entry in entries)
                if (args.Item.Id == "copyfilename")
                    copyText.Add(Path.GetFileName(entry));
                else if (args.Item.Id == "copyfolderpath")
                    copyText.Add(Path.GetDirectoryName(entry));
                else if (args.Item.Id == "copypath")
                    copyText.Add(entry);

        JSRuntime.InvokeVoidAsync("copyClipboard", string.Join(";", string.Join(";", copyText)));
    }

    public async void PatternTextBoxKeyUp(KeyboardEventArgs args)
    {
        if (args.Key == "Enter")
        {
            // We have to do it like that here as it seems like that the event is not in the UI thread for whatever reason
            await InvokeAsync(Search);
            StateHasChanged();
        }
    }
}
