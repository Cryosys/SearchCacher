@page "/"
@using SearchCacher.Data
@using System.ComponentModel.DataAnnotations
@using Syncfusion.Blazor.Buttons;
@using Syncfusion.Blazor.Grids
@using Syncfusion.Blazor.Navigations;
@using Syncfusion.Blazor.Inputs;
@using Syncfusion.Blazor.Notifications
@inject SearchService searchService

<PageTitle>OnlySearch</PageTitle>

<SfToast ID="toast_default" @ref="data.ToastObj" Title="Info" Timeout="5000" Icon="e-meeting">
    <ToastPosition X="Right" Y="Top" />
</SfToast>

<div>
    <div style="display:flex;align-items:start">
        <SfAccordion Width="auto" LoadOnDemand="false" style="min-width:300px">
            <AccordionItems>
                <AccordionItem Header="Settings" Expanded="true">
                    <ContentTemplate>
                        <table style="margin:10px;white-space:nowrap">
                            <thead>
                                <tr>
                                    <th style="padding-right:30px">Status</th>
                                    <th>Setting</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td><SfSwitch @bind-Checked="data.searchOnlyFileExt" /></td><td>Only search in extensions</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.searchOnFullPath" /></td><td>Search on full path</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.searchDirs" /></td><td>Directories</td></tr>
                                <tr><td><SfSwitch @bind-Checked="data.searchFiles" /></td><td>Files</td></tr>
                            </tbody>
                        </table>
                    </ContentTemplate>
                </AccordionItem>
            </AccordionItems>
        </SfAccordion>
        <SfAccordion LoadOnDemand="false">
            <AccordionItems>
                <AccordionItem Header="Info" Expanded="true">
                    <ContentTemplate>
                        <s>
                            Enabling only extensions makes the search absolut. Meaning that only the specified extension will be searched for. <br />
                            Example: You want to search for all txt files. Input only .txt in the search box, all other settings do not matter.<br />
                            The pattern is relative, meaning that '.txt' will only find a file for example that does not have a name and ends with '.txt'. Entering '*.txt' however will search for all files ending with '.txt'. <br />
                            Entering 'nua*' will search for all files and folders containing the char set 'nua' at any point in the name. Like Manual -> Ma*nua*l.
                        </s>
                        <br />
                        <br />
                        The search pattern is Regex based. <a href="https://regex101.com/" target="_blank">You can test and generate regex patterns here.</a><br/>
                        Tl:dr; writing only a word, for example 'test' will find all paths involing this word, regardless of upper or lower case and anywhere in the path. <br />
                        It does not matter if the word has something before or after it. Writing 'subfolder*.*test' will find all paths that have at some point subfolder in it and AFTER it somewhere test. <br />
                        The search will only search in paths if you enable the option, this will take a bit more time, but not that much more.
                    </ContentTemplate>
                </AccordionItem>
            </AccordionItems>
        </SfAccordion>
    </div>

    <div style="display:flex;flex-direction:row;text-align:center;align-items:center">
        <span style="margin-right:5px">Pattern:</span>
        <SfTextBox Multiline="false" Placeholder="*nua*" @bind-Value="data.pattern" style="min-width:400px;width:auto" />
        <SfButton style="margin:5px" @onclick=Search>Search</SfButton>
        <div style="position: relative;width:50px">
            <SfSpinner Size="20" @bind-Visible="@data.IsSpinnerVisible" />
        </div>
    </div>

    <SfGrid TValue="string" DataSource="@data.Paths" AllowPaging="true" AllowSorting="true">
        <GridPageSettings PageSize="50" />
        <GridColumns>
            <GridColumn HeaderText="File">
                <Template>
                    @{
                        <div>@(context as string)</div>
                    }
                </Template>
            </GridColumn>
        </GridColumns>
    </SfGrid>

    <br />
    Last search time @data.lastSearchTime min:sec:ms
</div>

@code {
    class FormData
    {
        public SfToast ToastObj;

        public bool IsSpinnerVisible { get; set; } = false;

        public string?[]? Paths { get; set; } = null;

        public string pattern { get; set; } = "nua*";

        public Task<string?[]>? searchTask;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchOnlyFileExt
        {
            get;
            set;
        } = false;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchOnFullPath
        {
            get;
            set;
        } = false;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchDirs
        {
            get;
            set;
        } = true;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool searchFiles
        {
            get;
            set;
        } = true;

        [Required]
        [Range(typeof(bool), "false", "true")]
        public bool SpinnerVisible { get; set; } = false;

        public string? lastSearchTime { get; set; } = null;
    }
    FormData data = new FormData();

    protected async Task Search()
    {
        if (data.searchTask is not null)
        {
            ShowToast("Previous search is still in progress...");
            return;
        }

        if (string.IsNullOrWhiteSpace(data.pattern))
        {
            ShowToast("Empty search pattern is not allowed.");
            return;
        }

        try
        {
            System.Text.RegularExpressions.Regex.IsMatch("", data.pattern);
        }
        catch (ArgumentException)
        {
            ShowToast("Pattern is not a valid regex pattern");
            return;
        }

        ShowToast("Starting search...");
        data.IsSpinnerVisible = true;
        await Task.Delay(100);
        data.Paths = null;

        DateTime preSearch = DateTime.Now;
        data.searchTask = searchService.GetSearchResult(new SearchSettings(data.pattern, data.searchOnlyFileExt, data.searchDirs, data.searchFiles, data.searchOnFullPath));
        await data.searchTask;
        if (data.searchTask.Status != TaskStatus.RanToCompletion)
        {
            ShowToast("Failed to init DB. Ex: " + data.searchTask.Exception?.ToString());
            return;
        }

        data.lastSearchTime = (DateTime.Now - preSearch).ToString(@"mm\:ss\:ffff", new System.Globalization.CultureInfo("en-US"));

        data.Paths = data.searchTask.Result;
        data.searchTask = null;
        data.IsSpinnerVisible = false;
        ShowToast("Finished search");
    }

    protected async void ShowToast(string info, int timeout = 2500)
    {
        await this.data.ToastObj.ShowAsync(new ToastModel()
            {
                Content = info,
                Timeout = timeout
            });
    }
}
